Index: libnautilus-private/nautilus-icon-factory.c
===================================================================
--- libnautilus-private/nautilus-icon-factory.c	(.../tags/NAUTILUS_2_20_0)	(revision 13249)
+++ libnautilus-private/nautilus-icon-factory.c	(.../branches/gnome-2-20)	(revision 13249)
@@ -200,7 +200,7 @@
 							  const char               *modifier,
 							  guint                     nominal_size,
 							  gboolean		    force_nominal);
-static void nautilus_icon_factory_clear                  (void);
+static void nautilus_icon_factory_clear                  (gboolean                  clear_pathnames);
 
 GNOME_CLASS_BOILERPLATE (NautilusIconFactory,
 			 nautilus_icon_factory,
@@ -270,7 +270,7 @@
 {
 	NautilusIconFactory *factory;
 
-	nautilus_icon_factory_clear ();
+	nautilus_icon_factory_clear (FALSE);
 
 	factory = user_data;
 
@@ -384,9 +384,21 @@
 		goto out;
 	}
 
+	if (!gdk_pixbuf_get_has_alpha (pixbuf)) {
+		/* we don't own the pixbuf, but nautilus_thumbnail_frame_image() assumes so and unrefs it. */
+		g_object_ref (pixbuf);
+
+		nautilus_thumbnail_frame_image (&pixbuf);
+		/* at this point, we own a pixbuf, which is the framed version of the passed-in pixbuf. */
+	}
+
 	cached_icon = cache_icon_new (pixbuf, NULL, scale_x, scale_y);
 	cached_icon->mtime = statbuf.st_mtime;
 
+	if (!gdk_pixbuf_get_has_alpha (pixbuf)) {
+		g_object_unref (pixbuf);
+	}
+
 	if (cached_icon != NULL) {
 		key = g_new (CacheKey, 1);
 		key->name = g_strdup (path);
@@ -714,9 +726,23 @@
         return TRUE;
 }
 
-/* Reset the cache to the default state. */
+static gboolean
+remove_non_pathnames (gpointer _key, gpointer value, gpointer user_data)
+{
+	CacheKey *key = _key;
+	
+	if (key->name && key->name[0] == '/') {
+		return FALSE;
+	}
+	    
+        return TRUE; /* Tell the caller to remove the hash table entry. */
+}
+
+/* Reset the cache to the default state.
+   Clear pathnames can be set to FALSE which means we only clear icon names, not
+   absolute pathnames. This is useful to avoid throwing away all loaded thumbnails. */
 static void
-nautilus_icon_factory_clear (void)
+nautilus_icon_factory_clear (gboolean clear_pathnames)
 {
 	NautilusIconFactory *factory;
 	CircularList *head;
@@ -724,24 +750,25 @@
 	factory = get_icon_factory ();
 
         g_hash_table_foreach_remove (factory->icon_cache,
-				     remove_all,
+				     clear_pathnames ? remove_all : remove_non_pathnames,
                                      NULL);
 	
 	/* Empty out the recently-used list. */
 	head = &factory->recently_used_dummy_head;
 
-	/* fallback_icon hangs around, but we don't know if it
-	 * was ever inserted in the list
-	 */
-	g_assert (factory->recently_used_count == 0 ||
-		  factory->recently_used_count == 1);
-
-	if (factory->recently_used_count == 1) {
-		/* make sure this one is the fallback_icon */
-		g_assert (head->next == head->prev);
-		g_assert (&factory->fallback_icon->recently_used_node == head->next);
+	if (clear_pathnames) {
+		/* fallback_icon hangs around, but we don't know if it
+		 * was ever inserted in the list
+		 */
+		g_assert (factory->recently_used_count == 0 ||
+			  factory->recently_used_count == 1);
+		if (factory->recently_used_count == 1) {
+			/* make sure this one is the fallback_icon */
+			g_assert (head->next == head->prev);
+			g_assert (&factory->fallback_icon->recently_used_node == head->next);
+		}
 	}
-
+		
 }
 
 static void
@@ -794,7 +821,7 @@
 	 * signal to mean only "thumbnails might have changed" if this ends up being slow
 	 * for some reason.
 	 */
-	nautilus_icon_factory_clear ();
+	nautilus_icon_factory_clear (TRUE);
 	g_signal_emit (global_icon_factory,
 			 signals[ICONS_CHANGED], 0);
 }
@@ -808,7 +835,7 @@
 	 * signal to mean only "thumbnails might have changed" if this ends up being slow
 	 * for some reason.
 	 */
-	nautilus_icon_factory_clear ();
+	nautilus_icon_factory_clear (TRUE);
 	g_signal_emit (global_icon_factory,
 			 signals[ICONS_CHANGED], 0);
 }
@@ -818,7 +845,7 @@
 {
 	show_image_thumbs = eel_preferences_get_enum (NAUTILUS_PREFERENCES_SHOW_IMAGE_FILE_THUMBNAILS);
 
-	nautilus_icon_factory_clear ();
+	nautilus_icon_factory_clear (TRUE);
 	/* If the user disabled thumbnailing, remove all outstanding thumbnails */ 
 	if (show_image_thumbs == NAUTILUS_SPEED_TRADEOFF_NEVER) {
 		nautilus_thumbnail_remove_all_from_queue ();
@@ -836,7 +863,7 @@
 	/* We don't know which data changed, so we have to assume that
 	 * any or all icons might have changed.
 	 */
-	nautilus_icon_factory_clear ();
+	nautilus_icon_factory_clear (FALSE);
 	g_signal_emit (get_icon_factory (), 
 			 signals[ICONS_CHANGED], 0);
 }				 
Index: libnautilus-private/nautilus-directory-async.c
===================================================================
--- libnautilus-private/nautilus-directory-async.c	(.../tags/NAUTILUS_2_20_0)	(revision 13249)
+++ libnautilus-private/nautilus-directory-async.c	(.../branches/gnome-2-20)	(revision 13249)
@@ -594,7 +594,7 @@
 		NAUTILUS_FILE_ATTRIBUTE_FILE_TYPE |
 		NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;
 
-	nautilus_directory_invalidate_file_attributes (dir, attrs);
+	nautilus_directory_force_reload_internal (dir, attrs);
 }
 
 void
