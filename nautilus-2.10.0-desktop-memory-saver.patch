===================================================================
RCS file: /cvs/gnome/nautilus/libnautilus-private/nautilus-directory-background.c,v
retrieving revision 1.95
diff -u -p -r1.95 nautilus-directory-background.c
--- libnautilus-private/nautilus-directory-background.c	31 Jan 2005 19:35:24 -0000	1.95
+++ libnautilus-private/nautilus-directory-background.c	15 Mar 2005 11:38:55 -0000
@@ -35,8 +35,6 @@
 #include "nautilus-metadata.h"
 #include "nautilus-file-attributes.h"
 #include <eel/eel-string.h>
-#include <X11/Xatom.h>
-#include <gdk/gdkx.h>
 #include <gtk/gtkmain.h>
 #include <gtk/gtksignal.h>
 #include <libgnome/gnome-config.h>
@@ -55,59 +53,11 @@ static void saved_settings_changed_callb
                                          
 static void nautilus_file_background_receive_gconf_changes (EelBackground *background);
 
-static void nautilus_file_update_root_pixmaps (EelBackground *background);
-
 static void nautilus_file_background_write_desktop_settings (char *color,
 							     char *image,
 							     EelBackgroundImagePlacement placement);
 static void nautilus_file_background_theme_changed (gpointer user_data);
 
-static void
-screen_size_changed (GdkScreen *screen, NautilusIconContainer *icon_container)
-{
-        EelBackground *background;
-        
-        background = eel_get_widget_background (GTK_WIDGET (icon_container));
-
-	nautilus_file_update_root_pixmaps (background);        
-}
-
-static void
-remove_connection (NautilusIconContainer *icon_container, GdkScreen *screen)
-{
-        g_signal_handlers_disconnect_by_func
-                (screen,
-                 G_CALLBACK (screen_size_changed),
-                 icon_container);
-}
-
-static void
-desktop_background_realized (NautilusIconContainer *icon_container, void *disconnect_signal)
-{
-	EelBackground *background;
-
-        if (GPOINTER_TO_INT (disconnect_signal)) {
-                g_signal_handlers_disconnect_by_func
-                        (icon_container,
-                         G_CALLBACK (desktop_background_realized),
-                         disconnect_signal);
-	}
-
-	background = eel_get_widget_background (GTK_WIDGET (icon_container));
-                                          
-	g_object_set_data (G_OBJECT (background), "icon_container", (gpointer) icon_container);
-
-	g_object_set_data (G_OBJECT (background), "screen",
-			   gtk_widget_get_screen (GTK_WIDGET (icon_container)));
-
-	nautilus_file_update_root_pixmaps (background);
-
-        g_signal_connect (gtk_widget_get_screen (GTK_WIDGET (icon_container)), "size_changed",
-                          G_CALLBACK (screen_size_changed), icon_container);
-        g_signal_connect (icon_container, "unrealize", G_CALLBACK (remove_connection), 
-                          gtk_widget_get_screen (GTK_WIDGET (icon_container)));
-}
-
 void
 nautilus_connect_desktop_background_to_file_metadata (NautilusIconContainer *icon_container,
                                                       NautilusFile *file)
@@ -115,9 +65,9 @@ nautilus_connect_desktop_background_to_f
 	EelBackground *background;
 
 	background = eel_get_widget_background (GTK_WIDGET (icon_container));
-        eel_background_set_is_constant_size (background, TRUE);
 
-	g_object_set_data (G_OBJECT (background), "is_desktop", (gpointer)1);
+	eel_background_set_is_constant_size (background, TRUE);
+	eel_background_set_desktop (background, GTK_WIDGET (icon_container), TRUE);
 
 	/* Strictly speaking, we don't need to know about metadata changes, since
 	 * the desktop setting aren't stored there. But, hooking up to metadata
@@ -129,22 +79,9 @@ nautilus_connect_desktop_background_to_f
 	 */
 	nautilus_connect_background_to_file_metadata (GTK_WIDGET (icon_container), file, NAUTILUS_DND_ACTION_SET_AS_FOLDER_BACKGROUND);
 
-	if (GTK_WIDGET_REALIZED (icon_container)) {
-		desktop_background_realized (icon_container, GINT_TO_POINTER (FALSE));
-	} else {
-		g_signal_connect (icon_container, "realize",
-                                  G_CALLBACK (desktop_background_realized), GINT_TO_POINTER (TRUE));
-	}
-
 	nautilus_file_background_receive_gconf_changes (background); 
 }
 
-static gboolean
-background_is_desktop (EelBackground *background)
-{
-	return g_object_get_data (G_OBJECT (background), "is_desktop") != 0;
-}
-
 static void
 nautilus_file_background_get_default_settings (char **color,
                                                char **image,
@@ -357,15 +294,31 @@ static void
 desktop_background_destroyed_callback (EelBackground *background, void *georgeWBush)
 {
 	guint notification_id;
+	guint notification_timeout_id;
 
         notification_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (background), "desktop_gconf_notification"));
 	eel_gconf_notification_remove (notification_id);
+
+	notification_timeout_id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (background), "desktop_gconf_notification_timeout"));
+	g_source_remove (notification_timeout_id);
 }
 
 static void
 desktop_background_gconf_notify_cb (GConfClient *client, guint notification_id, GConfEntry *entry, gpointer data)
 {
-	call_settings_changed (EEL_BACKGROUND (data));
+	EelBackground *background;
+	guint notification_timeout_id;
+	
+	background = EEL_BACKGROUND (data);
+	/* 
+	 * Wallpaper capplet changes picture, background color and placement with
+	 * gconf_change_set API, but unfortunately, this operation is not atomic in
+	 * GConf as it should be. So we update background after small timeout to
+	 * let GConf change all values.
+	 */
+	notification_timeout_id = g_timeout_add (300, (GSourceFunc) call_settings_changed, background);
+
+	g_object_set_data (G_OBJECT (background), "desktop_gconf_notification_timeout", GUINT_TO_POINTER (notification_timeout_id));
 }
 
 static void
@@ -382,190 +335,6 @@ nautilus_file_background_receive_gconf_c
                           G_CALLBACK (desktop_background_destroyed_callback), NULL);
 }
 
-/* Create a persistent pixmap. We create a separate display
- * and set the closedown mode on it to RetainPermanent
- * (copied from gnome-source/control-panels/capplets/background-properties/render-background.c)
- */
-static GdkPixmap *
-make_root_pixmap (GdkScreen *screen, gint width, gint height)
-{
-	Display *display;
-        const char *display_name;
-	Pixmap result;
-	GdkPixmap *gdk_pixmap;
-	int screen_num;
-
-	screen_num = gdk_screen_get_number (screen);
-
-	gdk_flush ();
-
-	display_name = gdk_display_get_name (gdk_screen_get_display (screen));
-	display = XOpenDisplay (display_name);
-
-        if (display == NULL) {
-                g_warning ("Unable to open display '%s' when setting background pixmap\n",
-                           (display_name) ? display_name : "NULL");
-                return NULL;
-        }
-
-	XSetCloseDownMode (display, RetainPermanent);
-
-	result = XCreatePixmap (display,
-				RootWindow (display, screen_num),
-				width, height,
-				DefaultDepth (display, screen_num));
-
-	XCloseDisplay (display);
-
-	gdk_pixmap = gdk_pixmap_foreign_new (result);
-	gdk_drawable_set_colormap (GDK_DRAWABLE (gdk_pixmap),
-				   gdk_drawable_get_colormap (gdk_screen_get_root_window (screen)));
-
-	return gdk_pixmap;
-}
-
-/* Set the root pixmap, and properties pointing to it. We
- * do this atomically with XGrabServer to make sure that
- * we won't leak the pixmap if somebody else it setting
- * it at the same time. (This assumes that they follow the
- * same conventions we do
- * (copied from gnome-source/control-panels/capplets/background-properties/render-background.c)
- */
-static void 
-set_root_pixmap (GdkPixmap *pixmap, GdkScreen *screen)
-{
-	int      result;
-	gint     format;
-	gulong   nitems;
-	gulong   bytes_after;
-	guchar  *data_esetroot;
-	Pixmap   pixmap_id;
-	Atom     type;
-	Display *display;
-	int      screen_num;
-
-	screen_num = gdk_screen_get_number (screen);
-
-	data_esetroot = NULL;
-	display = GDK_DISPLAY_XDISPLAY (gdk_screen_get_display (screen));
-
-	XGrabServer (display);
-
-	result = XGetWindowProperty (display, RootWindow (display, screen_num),
-				     gdk_x11_get_xatom_by_name ("ESETROOT_PMAP_ID"),
-				     0L, 1L, False, XA_PIXMAP,
-				     &type, &format, &nitems, &bytes_after,
-				     &data_esetroot);
-
-	if (data_esetroot != NULL) {
-		if (result == Success && type == XA_PIXMAP && format == 32 && nitems == 1) {
-			gdk_error_trap_push ();
-			XKillClient (display, *(Pixmap *)data_esetroot);
-			gdk_flush ();
-			gdk_error_trap_pop ();
-		}
-		XFree (data_esetroot);
-	}
-
-	pixmap_id = GDK_WINDOW_XWINDOW (pixmap);
-
-	XChangeProperty (display, RootWindow (display, screen_num),
-			 gdk_x11_get_xatom_by_name ("ESETROOT_PMAP_ID"), XA_PIXMAP,
-			 32, PropModeReplace,
-			 (guchar *) &pixmap_id, 1);
-	XChangeProperty (display, RootWindow (display, screen_num),
-			 gdk_x11_get_xatom_by_name ("_XROOTPMAP_ID"), XA_PIXMAP,
-			 32, PropModeReplace,
-			 (guchar *) &pixmap_id, 1);
-
-	XSetWindowBackgroundPixmap (display, RootWindow (display, screen_num), pixmap_id);
-	XClearWindow (display, RootWindow (display, screen_num));
-
-	XUngrabServer (display);
-	
-	XFlush (display);
-}
-
-/* Free the root pixmap */
-static void
-image_loading_done_callback (EelBackground *background, gboolean successful_load, void *disconnect_signal)
-{
-	int           entire_width;
-	int           entire_height;
-	int           pixmap_width;
-	int           pixmap_height;
-	GdkGC        *gc;
-	GdkPixmap    *pixmap;
-	GdkWindow    *background_window;
-	GdkScreen    *screen;
-        GdkColor parsed_color;
-        char * color_string;
-
-        if (GPOINTER_TO_INT (disconnect_signal)) {
-		g_signal_handlers_disconnect_by_func
-                        (background,
-                         G_CALLBACK (image_loading_done_callback),
-                         disconnect_signal);
-	}
-
-	screen = g_object_get_data (G_OBJECT (background), "screen");
-	if (screen == NULL) {
-		return;
-        }
-	entire_width = gdk_screen_get_width (screen);
-	entire_height = gdk_screen_get_height (screen);
-
-	if (eel_background_get_suggested_pixmap_size (background, entire_width, entire_height,
-                                                      &pixmap_width, &pixmap_height)) {
-                eel_background_pre_draw (background, entire_width, entire_height);
-                /* image resize may have forced us to reload the image */
-                if (!eel_background_is_loaded (background)) {
-                        g_signal_connect (background, "image_loading_done",
-                                          G_CALLBACK (image_loading_done_callback),
-                                          GINT_TO_POINTER (TRUE));
-                        return;
-                }
-	} else {
-                pixmap_width = pixmap_height = 1;
-
-		background_window = gdk_screen_get_root_window (screen);
-		color_string = eel_background_get_color (background);
-
-		if (background_window != NULL && color_string != NULL) {
-			if (eel_gdk_color_parse (color_string, &parsed_color)) {
-                                gdk_rgb_find_color (gdk_drawable_get_colormap (background_window), &parsed_color);
-				gdk_window_set_background (background_window, &parsed_color);
-			}
-		}
-		g_free (color_string);
-	}
-
-        pixmap = make_root_pixmap (screen, pixmap_width, pixmap_height);
-        if (pixmap == NULL) {
-                return;
-        }
-        
-        gc = gdk_gc_new (pixmap);
-        eel_background_draw (background, pixmap, gc,
-                             0, 0, 0, 0,
-                             pixmap_width, pixmap_height);
-        g_object_unref (gc);
-        set_root_pixmap (pixmap, screen);
-        g_object_unref (pixmap);
-}
-
-static void
-nautilus_file_update_root_pixmaps (EelBackground *background)
-{
-	if (eel_background_is_loaded (background)) {
-		image_loading_done_callback (background, TRUE, GINT_TO_POINTER (FALSE));
-	} else {
-		g_signal_connect (background, "image_loading_done",
-                                  G_CALLBACK (image_loading_done_callback),
-                                  GINT_TO_POINTER (TRUE));
-	}
-}
-
 /* return true if the background is not in the default state */
 gboolean
 nautilus_file_background_is_set (EelBackground *background)
@@ -603,7 +372,7 @@ background_changed_callback (EelBackgrou
 	color = eel_background_get_color (background);
 	image = eel_background_get_image_uri (background);
 
-	if (background_is_desktop (background)) {
+	if (eel_background_is_desktop (background)) {
 		nautilus_file_background_write_desktop_settings (color, image, eel_background_get_image_placement (background));
 	} else {
 	        /* Block the other handler while we are writing metadata so it doesn't
@@ -657,10 +426,6 @@ background_changed_callback (EelBackgrou
 
 	g_free (color);
 	g_free (image);
-	
-	if (background_is_desktop (background)) {
-		nautilus_file_update_root_pixmaps (background);
-	}
 }
 
 static gboolean
@@ -677,7 +442,7 @@ initialize_background_from_settings (Nau
         g_assert (g_object_get_data (G_OBJECT (background), "eel_background_file")
                   == file);
 
-	if (background_is_desktop (background)) {
+	if (eel_background_is_desktop (background)) {
 		nautilus_file_background_read_desktop_settings (&color, &image, &placement);
 	} else {
 		color = nautilus_file_get_metadata (file,
@@ -715,7 +480,7 @@ initialize_background_from_settings (Nau
 
         old_image = eel_background_get_image_uri (background);
         if (eel_strcmp (image, old_image) != 0) {
-                if (background_is_desktop(background)) {
+                if (eel_background_is_desktop(background)) {
                         eel_background_set_image_uri_sync (background, image);
                 }
                 else {
@@ -750,10 +515,6 @@ saved_settings_changed_callback (Nautilu
 {
         gboolean changed;
 	changed = initialize_background_from_settings (file, background);
-	
-	if (changed && background_is_desktop (background)) {
-		nautilus_file_update_root_pixmaps (background);
-	}
 }
 
 /* handle the theme changing */
@@ -778,7 +539,7 @@ background_reset_callback (EelBackground
         char *color;
         char *image;
 
-	if (background_is_desktop (background)) {
+	if (eel_background_is_desktop (background)) {
 		nautilus_file_background_write_desktop_default_settings ();
 	} else {
 	        /* Block the other handler while we are writing metadata so it doesn't
Index: nautilus-icon-dnd.c
===================================================================
RCS file: /cvs/gnome/nautilus/libnautilus-private/nautilus-icon-dnd.c,v
retrieving revision 1.141
diff -u -p -r1.141 nautilus-icon-dnd.c
--- libnautilus-private/nautilus-icon-dnd.c	13 Jan 2005 13:27:51 -0000	1.141
+++ libnautilus-private/nautilus-icon-dnd.c	15 Mar 2005 11:38:55 -0000
@@ -536,7 +534,7 @@ get_background_drag_action (NautilusIcon
 
 	if (action == GDK_ACTION_ASK) {
 		valid_actions = NAUTILUS_DND_ACTION_SET_AS_FOLDER_BACKGROUND;
-		if (g_object_get_data (G_OBJECT (eel_get_widget_background (GTK_WIDGET (container))), "is_desktop") == 0) {
+		if (!eel_background_is_desktop (eel_get_widget_background (GTK_WIDGET (container)))) {
 			valid_actions |= NAUTILUS_DND_ACTION_SET_AS_GLOBAL_BACKGROUND;
 		}
 
Index: libnautilus-private/nautilus-window-info.c
===================================================================
RCS file: /cvs/gnome/nautilus/libnautilus-private/nautilus-window-info.c,v
retrieving revision 1.2
diff -u -p -r1.2 nautilus-window-info.c
--- libnautilus-private/nautilus-window-info.c	22 Nov 2004 15:24:36 -0000	1.2
+++ libnautilus-private/nautilus-window-info.c	18 Mar 2005 23:28:15 -0000
@@ -168,6 +168,14 @@ nautilus_window_info_open_location (Naut
 }
 
 void
+nautilus_window_info_show_window (NautilusWindowInfo      *window)
+{
+	g_return_if_fail (NAUTILUS_IS_WINDOW_INFO (window));
+
+	(* NAUTILUS_WINDOW_INFO_GET_IFACE (window)->show_window) (window);
+}
+
+void
 nautilus_window_info_close (NautilusWindowInfo      *window)
 {
 	g_return_if_fail (NAUTILUS_IS_WINDOW_INFO (window));
Index: libnautilus-private/nautilus-window-info.h
===================================================================
RCS file: /cvs/gnome/nautilus/libnautilus-private/nautilus-window-info.h,v
retrieving revision 1.2
diff -u -p -r1.2 nautilus-window-info.h
--- libnautilus-private/nautilus-window-info.h	22 Nov 2004 15:24:36 -0000	1.2
+++ libnautilus-private/nautilus-window-info.h	18 Mar 2005 23:28:15 -0000
@@ -127,6 +127,7 @@ struct _NautilusWindowInfoIface 
 				       NautilusWindowOpenMode mode,
 				       NautilusWindowOpenFlags flags,
 				       GList *selection);
+	void   (* show_window)        (NautilusWindowInfo *window);
 	void   (* close_window)       (NautilusWindowInfo *window);
 	GtkUIManager *     (* get_ui_manager)   (NautilusWindowInfo *window);
 };
@@ -144,6 +145,7 @@ void                              nautil
 										 NautilusWindowOpenMode             mode,
 										 NautilusWindowOpenFlags            flags,
 										 GList                             *selection);
+void                              nautilus_window_info_show_window              (NautilusWindowInfo                *window);
 void                              nautilus_window_info_close                    (NautilusWindowInfo                *window);
 void                              nautilus_window_info_set_status               (NautilusWindowInfo                *window,
 										 const char                        *status);
Index: src/nautilus-window-manage-views.c
===================================================================
RCS file: /cvs/gnome/nautilus/src/nautilus-window-manage-views.c,v
retrieving revision 1.347
diff -u -p -r1.347 nautilus-window-manage-views.c
--- src/nautilus-window-manage-views.c	14 Feb 2005 10:59:23 -0000	1.347
+++ src/nautilus-window-manage-views.c	18 Mar 2005 23:28:15 -0000
@@ -1106,11 +1106,6 @@ location_has_really_changed (NautilusWin
 
         free_location_change (window);
 
-        nautilus_window_update_title (window);
-	nautilus_window_update_icon (window);
-
-	gtk_widget_show (GTK_WIDGET (window));
-
 	if (location_copy != NULL) {
 		g_signal_emit_by_name (window, "loading_uri",
 				       location_copy);
Index: src/nautilus-window.c
===================================================================
RCS file: /cvs/gnome/nautilus/src/nautilus-window.c,v
retrieving revision 1.443
diff -u -p -r1.443 nautilus-window.c
--- src/nautilus-window.c	22 Feb 2005 08:46:38 -0000	1.443
+++ src/nautilus-window.c	18 Mar 2005 23:28:16 -0000
@@ -559,6 +559,26 @@ nautilus_window_finalize (GObject *objec
 }
 
 void
+nautilus_window_show_window (NautilusWindow *window)
+{
+	g_return_if_fail (NAUTILUS_IS_WINDOW (window));
+
+	EEL_CALL_METHOD (NAUTILUS_WINDOW_CLASS, window,
+			 show_window, (window));
+
+	nautilus_window_update_title (window);
+	nautilus_window_update_icon (window);
+
+	gtk_widget_show (GTK_WIDGET (window));
+
+	if (window->details->viewed_file) {
+		if (NAUTILUS_IS_SPATIAL_WINDOW (window)) {
+			nautilus_file_set_has_open_window (window->details->viewed_file, TRUE);
+		}
+	}
+}
+
+void
 nautilus_window_close (NautilusWindow *window)
 {
 	g_return_if_fail (NAUTILUS_IS_WINDOW (window));
@@ -1186,9 +1206,6 @@ nautilus_window_set_viewed_file (Nautilu
 	}
 
 	if (file != NULL) {
-		if (NAUTILUS_IS_SPATIAL_WINDOW (window)) {
-			nautilus_file_set_has_open_window (file, TRUE);
-		}
 		attributes = NAUTILUS_FILE_ATTRIBUTE_DISPLAY_NAME | NAUTILUS_FILE_ATTRIBUTE_SLOW_MIME_TYPE;
 		nautilus_file_monitor_add (file, window, attributes);
 	}
@@ -1407,6 +1424,7 @@ nautilus_window_info_iface_init (Nautilu
 	iface->report_selection_changed = nautilus_window_report_selection_changed;
 	iface->report_view_failed = nautilus_window_report_view_failed;
 	iface->open_location = nautilus_window_open_location_full;
+	iface->show_window = nautilus_window_show_window;
 	iface->close_window = nautilus_window_close;
 	iface->set_status = nautilus_window_set_status;
 	iface->get_window_type = nautilus_window_get_window_type;
Index: src/nautilus-window.h
===================================================================
RCS file: /cvs/gnome/nautilus/src/nautilus-window.h,v
retrieving revision 1.117
diff -u -p -r1.117 nautilus-window.h
--- src/nautilus-window.h	22 Nov 2004 15:24:37 -0000	1.117
+++ src/nautilus-window.h	18 Mar 2005 23:28:16 -0000
@@ -74,6 +74,7 @@ typedef struct {
                                         gboolean active);
         void   (* prompt_for_location) (NautilusWindow *window);
         void   (* get_default_size) (NautilusWindow *window, guint *default_width, guint *default_height);
+        void   (* show_window)  (NautilusWindow *window);
         void   (* close) (NautilusWindow *window);
 
         /* Signals used only for keybindings */
@@ -110,6 +111,7 @@ struct NautilusWindow {
 };
 
 GType            nautilus_window_get_type             (void);
+void             nautilus_window_show_window          (NautilusWindow    *window);
 void             nautilus_window_close                (NautilusWindow    *window);
 char *           nautilus_window_get_location         (NautilusWindow    *window);
 void             nautilus_window_go_to                (NautilusWindow    *window,
Index: src/file-manager/fm-directory-view.c
===================================================================
RCS file: /cvs/gnome/nautilus/src/file-manager/fm-directory-view.c,v
retrieving revision 1.662
diff -u -p -r1.662 fm-directory-view.c
--- src/file-manager/fm-directory-view.c	12 Mar 2005 11:45:12 -0000	1.662
+++ src/file-manager/fm-directory-view.c	18 Mar 2005 23:28:16 -0000
@@ -7069,6 +7069,9 @@ finish_loading (FMDirectoryView *view)
 	 * Subclasses use this to know that the new metadata is now available.
 	 */
 	fm_directory_view_begin_loading (view);
+	
+	/* Assume we have now all information to show window */
+	nautilus_window_info_show_window  (view->details->window);
 
 	if (nautilus_directory_are_all_files_seen (view->details->model)) {
 		schedule_idle_display_of_pending_files (view);		
